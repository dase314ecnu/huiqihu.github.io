

## 关于Peter Bailis 的两篇论文 

1. ["Highly Available Transactions: Virtues and Limitations"](https://www.vldb.org/pvldb/vol7/p181-bailis.pdf). 这篇论文探讨High available transaction. 这里的available类似CAP里的available。在network failure的情况下服务是否可用。差不多等价于如果操作是Coordination-free的，那么可以认为是high available的。文中的操作可以理解为transaction. 论文基本上把哪些操作可以做到high available理清楚了。但给出的结论对数据库系统内核似乎不太有用，对应用层一致性设计可能会有帮助。 

比如对Read Uncommitted (RU) 级别， 是可以做到Coordination-free的。 在论文中是这样理解的: 如果两个事务 T1: W1(x) W1(y) 和 T2: W2(x)W2(y)分别在两台机器上（比如进程M1和进程M2上执行，更多情况下在数据库中可以理解为主和备上）执行，他们可以无协商做到RU隔离级别。做到RU只要系统不要出现 W1(x)W2(x)W2(y)W1(Y)这样的写上的逆序冲突的调度即可。事实上M1和M2无须协商就可以避免上述调度，并各自提交事务。 原因是只要给所有操作按照他们机器的id确定事务顺序即可。比如M1的序可以定位 1, M2的序定为2。 如果系统记住这一规则，那么出现系统异常一定可以恢复到正确的状态（正确是指达到RU的状态）。 比如按上述规则，M1和M2可以无协商提交事务，即使在网络分区的情况下。在宕机情况下，系统也可以恢复到正确状态(M2写入的状态，映不可能是类似W1(x)W2(x)W2(y)W1(Y)这样的状态)。
  
  比较tricky的是Read Commit(RC)级别，




  
  
