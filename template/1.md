

## 关于Peter Bailis 的两篇论文 


1. ["Highly Available Transactions: Virtues and Limitations"](https://www.vldb.org/pvldb/vol7/p181-bailis.pdf). 

这篇论文探讨High available transaction. 这里的available类似CAP里的available。在network failure的情况下服务是否可用。差不多等价于如果操作是Coordination-free的，那么可以认为是high available的。文中的操作可以理解为transaction. 论文基本上把哪些操作可以做到high available理清楚了。但给出的结论对数据库系统内核似乎不太有用，对应用层一致性设计可能会有帮助。 

比如对Read Uncommitted (RU) 级别， 是可以做到Coordination-free的。 在论文中是这样理解的: 如果两个事务 T1: W1(x) W1(y) 和 T2: W2(x)W2(y)分别在两台机器上（比如进程M1和进程M2上执行，更多情况下在数据库中可以理解为主和备上）执行，他们可以无协商做到RU隔离级别。做到RU只要系统不要出现 W1(x)W2(x)W2(y)W1(Y)这样的写上的逆序冲突的调度即可。事实上M1和M2无须协商就可以避免上述调度，并各自提交事务。 原因是只要给所有操作按照他们机器的id确定事务顺序即可。比如M1的序可以定位 1, M2的序定为2。 如果系统记住这一规则，那么出现系统异常一定可以恢复到正确的状态（正确是指达到RU的状态）。 比如按上述规则，M1和M2可以无协商提交事务，即使在网络分区的情况下。在宕机情况下，系统也可以恢复到正确状态(M2写入的状态，一定不会是类似W1(x)W2(x)W2(y)W1(Y)这样调度之后的状态)。
  
  比较tricky的是Read Commit(RC)级别，论文中认为RC也可以做到无协商Coordination-free。 RC级别下读操作必须读到已提交的结果，论文中并不管这个结果的新旧，仅确保读操作读到的是已提交的。这显然是可以无协商解决的，因为M1和M2可以分别读自己本身提交的数据，不管对方的提交，即在本地做一个缓冲区，保证本地提交的原子性即可，这保证了M1和M2分别读到已提交的数据，即所谓RC。可以看出这种读操作其实是非常弱的，读版本的新旧是一个问题，不同机器上的不同版本也是问题。与通常数据库中理解的RC(比如PG, MYSQL支持的RC)达到的效果差异比较大。当然有一些一致性论文也指出了是可以改善的（MAV也可以通过无协商解决）。
  
  论文还有一些结论是有些一致性必须要求操作协商，比如达到SI是无法做到无协商的。在一定程度可以帮助我们设计协议时明确是否需要协商（我们知道SI不能做到无协商那就不要费力去想无协商的协议了），当然很多时候这是比较直观的。
  
  
  2. [Scalable Atomic Visibility with RAMP Transactions](https://dsf.berkeley.edu/jmh/papers/ramp-tods2016.pdf)

这篇论文是有一个比较精巧的idea的. 问题本身是解决分布式场景下读原子性（RA）的一个问题。一个只读事务要读到一个版本的数据。通常情况下实现这一要求读会被写（通过lamport lock等方式，或者读等待）阻塞，但论文给出了一种无阻塞的方法，这也是比较精巧的地方。 将读和写都拆分成2阶段，其中读在某些情况下可以一阶段完成。
  

在其期刊的论文中，讨论了RA隔离级别与其他隔离级别的关系。 论文引用Ayda的方法使用DSG上来探讨隔离级别，感觉比ANSI介绍的更容易理解一些。比如对Snapshot Isolation这一隔离级别的理解，通常认为是一种基于实现的隔离级别，但是Ayda的论文中给出了SI非基于实现要保证的事情以及防止的异常，可以说是非常清楚的。




  
  
